[{"id":"export_to_docx","name":"Export to DOCX","meta":{"description":"A comprehensive function for Open WebUI that converts AI responses in Markdown format to Word documents (.docx) with preserved formatting and automatic download in the browser.","type":"action","manifest":{"title":"Salvar para Word (completo)","author":"Jo√£o Back","author_url":"\"https://sinapse.tech\"","version":"0.1.0","required_open_webui_version":"\"0.5.0\"","description":"Converte toda a √∫ltima resposta da IA (Markdown) em um arquivo Word (.docx), preservando formata√ß√£o (t√≠tulos, par√°grafos, √™nfases, c√≥digo, listas, cita√ß√µes, tabelas e links) e dispara o download no navegador.","icon_url":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9IiMwMDAwMDAiIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDE0IDE0IiByb2xlPSJpbWciIGZvY3VzYWJsZT0iZmFsc2UiIGFyaWEtaGlkZGVuPSJ0cnVlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Im0gMTIuOTk5OTkyLDIuODY2MzMxIDAsOC4yNzM4MzkgYyAwLDAuMDcwNSAtMC4wMjUsMC4xMjc1MDUgLTAuMDc0NSwwLjE3MzAwNyAtMC4wNTA1LDAuMDQ3IC0wLjExMDUwNSwwLjA2OSAtMC4xODAwMDgsMC4wNjkgbCAtNC4yNzk2NzUxLDAgMCwtMS4xNDc1NDcgMy40OTExNDMxLDAgMCwtMC41MjI1MjIgLTMuNDk0MTQzMiwwIDAsLTAuNjM5NTI2IDMuNDkxMTQzMiwwIDAsLTAuNTIyMDIxIC0zLjQ4ODY0MzEsMCAwLC0wLjY0NTAyNyAzLjQ5MDE0MzEsMCAwLC0wLjUxNjAyMSAtMy40OTAxNDMxLDAgMCwtMC42NDY1MjYgMy40OTAxNDMxLDAgMCwtMC41MjIwMjIgLTMuNDkwMTQzMSwwIDAsLTAuNjM5NTI2IDMuNDkwMTQzMSwwIDAsLTAuNTIxNTIxIC0zLjQ5MDE0MzEsMCAwLC0wLjY1MjUyNyAzLjQ5MDE0MzEsMCAwLC0wLjQ5NzAyMSAtMy40OTAxNDMxLDAgMCwtMS4yOTY1NTMgNC4yODExNzUxLDAgYyAwLjA3NDUsMCAwLjEzNTAwNiwwLjAyNCAwLjE3OTAwOCwwLjA3NDUgMC4wNTI1LDAuMDQ5NSAwLjA3NSwwLjExMDAwNSAwLjA3NDUsMC4xNzgwMDggeiBtIC01LjE3NDcxMjMsLTEuNTQ2MDY0IDAsMTEuMzYxNDY2IC02LjgyNTI3OTc3LC0xLjE4MTA0OCAwLC04Ljk2NzM2OCA2LjgyNTI3OTc3LC0xLjIxNTA1IDAsMC4wMDIgeiBtIC0xLjAzMDA0MjMsMy4zNTQxMzggLTAuODU0NTM1LDAuMDUyNSAtMC41NDgwMjI1LDMuMzkyNjM5IC0wLjAxMjUwMSwwIEMgNS4zNTMxNzgzLDcuOTU5MDM5IDUuMjUyNjc0Miw3LjM5NzAxNiA1LjA3MjY2NjgsNi40MzU5NzcgTCA0Ljc1MzE1MzcsNC44MDQ0MSAzLjk1MTEyMDksNC44NDQ0MSAzLjYzMDEwNzcsNi40MzU5NzUgQyAzLjQ0MjYsNy4zNjMwMTMgMy4zMzgwOTU3LDcuOTAyNTM1IDMuMzEwNTk0Niw4LjA1NDA0MSBsIC0wLjAwNzUsMCAtMC40ODc1MiwtMy4xMjUxMjggLTAuNzM1MDMwMSwwLjAzOSAwLjc4NzUzMjMsMy45NDE2NjEgMC44MTcwMzM1LDAuMDUyNSAwLjMwNzUxMjYsLTEuNTM0MDYzIEMgNC4xNzI2Mjk5LDYuNTI3OTgxIDQuMjc3NjM0Miw2LjAwNDk1OSA0LjMwMDEzNTIsNS44NjE5NTMgbCAwLjAyMjUwMSwwIGMgMC4wMzA1MDEsMC4xNTI1MDcgMC4xMjgwMDUyLDAuNjg3MDI5IDAuMzA3NTEyNiwxLjYwNTA2NiBsIDAuMzA3NTEyNiwxLjU3OTA2NSAwLjg4NTAzNjMsMC4wNTI1IDAuOTkwMDQwNiwtNC40MjUxODEgLTAuMDE3NTAxLDAgeiIvPjwvc3ZnPg==","requirements":"python-docx>=1.1.0"}},"content":"\"\"\"\ntitle: Salvar para Word (completo)\nauthor: Jo√£o Back\nauthor_url: \"https://sinapse.tech\"\nversion: 0.1.0\nrequired_open_webui_version: \"0.5.0\"\ndescription: Converte toda a √∫ltima resposta da IA (Markdown) em um arquivo Word (.docx), preservando formata√ß√£o (t√≠tulos, par√°grafos, √™nfases, c√≥digo, listas, cita√ß√µes, tabelas e links) e dispara o download no navegador.\nicon_url:  data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9IiMwMDAwMDAiIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDE0IDE0IiByb2xlPSJpbWciIGZvY3VzYWJsZT0iZmFsc2UiIGFyaWEtaGlkZGVuPSJ0cnVlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Im0gMTIuOTk5OTkyLDIuODY2MzMxIDAsOC4yNzM4MzkgYyAwLDAuMDcwNSAtMC4wMjUsMC4xMjc1MDUgLTAuMDc0NSwwLjE3MzAwNyAtMC4wNTA1LDAuMDQ3IC0wLjExMDUwNSwwLjA2OSAtMC4xODAwMDgsMC4wNjkgbCAtNC4yNzk2NzUxLDAgMCwtMS4xNDc1NDcgMy40OTExNDMxLDAgMCwtMC41MjI1MjIgLTMuNDk0MTQzMiwwIDAsLTAuNjM5NTI2IDMuNDkxMTQzMiwwIDAsLTAuNTIyMDIxIC0zLjQ4ODY0MzEsMCAwLC0wLjY0NTAyNyAzLjQ5MDE0MzEsMCAwLC0wLjUxNjAyMSAtMy40OTAxNDMxLDAgMCwtMC42NDY1MjYgMy40OTAxNDMxLDAgMCwtMC41MjIwMjIgLTMuNDkwMTQzMSwwIDAsLTAuNjM5NTI2IDMuNDkwMTQzMSwwIDAsLTAuNTIxNTIxIC0zLjQ5MDE0MzEsMCAwLC0wLjY1MjUyNyAzLjQ5MDE0MzEsMCAwLC0wLjQ5NzAyMSAtMy40OTAxNDMxLDAgMCwtMS4yOTY1NTMgNC4yODExNzUxLDAgYyAwLjA3NDUsMCAwLjEzNTAwNiwwLjAyNCAwLjE3OTAwOCwwLjA3NDUgMC4wNTI1LDAuMDQ5NSAwLjA3NSwwLjExMDAwNSAwLjA3NDUsMC4xNzgwMDggeiBtIC01LjE3NDcxMjMsLTEuNTQ2MDY0IDAsMTEuMzYxNDY2IC02LjgyNTI3OTc3LC0xLjE4MTA0OCAwLC04Ljk2NzM2OCA2LjgyNTI3OTc3LC0xLjIxNTA1IDAsMC4wMDIgeiBtIC0xLjAzMDA0MjMsMy4zNTQxMzggLTAuODU0NTM1LDAuMDUyNSAtMC41NDgwMjI1LDMuMzkyNjM5IC0wLjAxMjUwMSwwIEMgNS4zNTMxNzgzLDcuOTU5MDM5IDUuMjUyNjc0Miw3LjM5NzAxNiA1LjA3MjY2NjgsNi40MzU5NzcgTCA0Ljc1MzE1MzcsNC44MDQ0MSAzLjk1MTEyMDksNC44NDQ0MSAzLjYzMDEwNzcsNi40MzU5NzUgQyAzLjQ0MjYsNy4zNjMwMTMgMy4zMzgwOTU3LDcuOTAyNTM1IDMuMzEwNTk0Niw4LjA1NDA0MSBsIC0wLjAwNzUsMCAtMC40ODc1MiwtMy4xMjUxMjggLTAuNzM1MDMwMSwwLjAzOSAwLjc4NzUzMjMsMy45NDE2NjEgMC44MTcwMzM1LDAuMDUyNSAwLjMwNzUxMjYsLTEuNTM0MDYzIEMgNC4xNzI2Mjk5LDYuNTI3OTgxIDQuMjc3NjM0Miw2LjAwNDk1OSA0LjMwMDEzNTIsNS44NjE5NTMgbCAwLjAyMjUwMSwwIGMgMC4wMzA1MDEsMC4xNTI1MDcgMC4xMjgwMDUyLDAuNjg3MDI5IDAuMzA3NTEyNiwxLjYwNTA2NiBsIDAuMzA3NTEyNiwxLjU3OTA2NSAwLjg4NTAzNjMsMC4wNTI1IDAuOTkwMDQwNiwtNC40MjUxODEgLTAuMDE3NTAxLDAgeiIvPjwvc3ZnPg==\nrequirements: python-docx>=1.1.0\n\"\"\"\n\nimport os\nimport re\nimport io\nimport base64\nimport datetime\nimport html\nimport logging\nfrom fastapi import FastAPI, HTTPException\nfrom typing import Optional, Callable, Awaitable, Any, List, Dict\n\napp = FastAPI()\n\n\nclass Action:\n    class UserValves:\n        def __init__(self, show_status: bool = True):\n            self.show_status = show_status\n\n    def __init__(self):\n        pass\n\n    async def action(\n        self,\n        body: dict,\n        __user__=None,\n        __event_emitter__=None,\n        __event_call__: Optional[Callable[[Any], Awaitable[None]]] = None,\n    ):\n        print(f\"action:{__name__}\")\n        user_valves = __user__.get(\"valves\") if __user__ else None\n        if not user_valves:\n            user_valves = self.UserValves()\n\n        if __event_emitter__ and user_valves.show_status:\n            await __event_emitter__(\n                {\"type\": \"status\", \"data\": {\"description\": \"Gerando documento Word...\", \"done\": False}}\n            )\n\n        try:\n            # imports lazy para n√£o travar o carregamento quando n√£o usados\n            try:\n                from docx import Document\n                from docx.shared import Pt, Inches\n                from docx.enum.text import WD_ALIGN_PARAGRAPH\n                from docx.enum.table import WD_TABLE_ALIGNMENT\n                from docx.oxml import OxmlElement\n                from docx.oxml.ns import qn\n                from docx.opc.constants import RELATIONSHIP_TYPE as RT\n            except ImportError:\n                raise HTTPException(\n                    status_code=500,\n                    detail=\"Depend√™ncia ausente: python-docx. Instale com: pip install python-docx\",\n                )\n\n            last_assistant_message = body[\"messages\"][-1]\n            content: str = last_assistant_message[\"content\"]\n\n            # nomes din√¢micos\n            title_text = self._extract_main_title(content) or \"\"\n            user_name = (__user__ or {}).get(\"name\", \"User\")\n            ts = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            if not title_text:\n                title_text = f\"{user_name}_Resposta_{ts}\"\n            filename = f\"{self._clean_filename(title_text)}.docx\"\n            \n            # Verificar e criar diret√≥rio tempor√°rio\n            temp_dir = os.path.join(\"app\", \"backend\", \"data\", \"temp\")\n            if not os.path.exists(temp_dir):\n                try:\n                    os.makedirs(temp_dir, exist_ok=True)\n                except OSError as e:\n                    # Fallback para diret√≥rio tempor√°rio do sistema\n                    import tempfile\n                    temp_dir = tempfile.gettempdir()\n                    logging.warning(f\"Usando diret√≥rio tempor√°rio do sistema: {temp_dir}\")\n            \n            doc_path = os.path.join(temp_dir, filename)\n\n            # cria documento\n            doc = Document()\n            if title_text:\n                h = doc.add_heading(title_text, level=0)\n                h.alignment = WD_ALIGN_PARAGRAPH.LEFT\n\n            # convers√£o completa Markdown -> DOCX\n            self._markdown_to_docx(\n                doc=doc,\n                md_text=content,\n                Inches=Inches,\n                Pt=Pt,\n                WD_TABLE_ALIGNMENT=WD_TABLE_ALIGNMENT,\n                WD_ALIGN_PARAGRAPH=WD_ALIGN_PARAGRAPH,\n                OxmlElement=OxmlElement,\n                qn=qn,\n                RT=RT,\n            )\n\n            # salva tempor√°rio\n            doc.save(doc_path)\n\n            # dispara download\n            if __event_call__:\n                try:\n                    with open(doc_path, \"rb\") as f:\n                        file_bytes = f.read()\n                        \n                    # Verificar tamanho do arquivo (limite de 50MB)\n                    if len(file_bytes) > 50 * 1024 * 1024:\n                        raise HTTPException(\n                            status_code=413,\n                            detail=\"Arquivo muito grande (>50MB). Reduza o conte√∫do.\"\n                        )\n                    \n                    b64 = base64.b64encode(file_bytes).decode(\"utf-8\")\n                    # Sanitizar nome do arquivo para JavaScript\n                    safe_filename = html.escape(filename).replace('\"', '&quot;')\n\n                    await __event_call__(\n                        {\n                            \"type\": \"execute\",\n                            \"data\": {\n                                \"code\": f\"\"\"\n                                try {{\n                                    const base64Data = \"{b64}\";\n                                    const binary = atob(base64Data);\n                                    const arrayBuffer = new Uint8Array(binary.length);\n                                    for (let i = 0; i < binary.length; i++) {{\n                                        arrayBuffer[i] = binary.charCodeAt(i);\n                                    }}\n                                    const blob = new Blob([arrayBuffer], {{\n                                        type: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n                                    }});\n                                    const filename = \"{safe_filename}\";\n                                    const url = URL.createObjectURL(blob);\n                                    const a = document.createElement(\"a\");\n                                    a.style.display = \"none\";\n                                    a.href = url;\n                                    a.download = filename;\n                                    document.body.appendChild(a);\n                                    a.click();\n                                    URL.revokeObjectURL(url);\n                                    document.body.removeChild(a);\n                                }} catch (err) {{\n                                    console.error(\"Error triggering download:\", err);\n                                    alert(\"Erro ao baixar arquivo. Verifique o console.\");\n                                }}\n                                \"\"\"\n                            },\n                        }\n                    )\n                except IOError as e:\n                    logging.error(f\"Erro ao ler arquivo: {e}\")\n                    raise HTTPException(status_code=500, detail=f\"Erro ao ler arquivo: {str(e)}\")\n\n            if __event_emitter__ and user_valves.show_status:\n                await __event_emitter__(\n                    {\"type\": \"status\", \"data\": {\"description\": \"Documento gerado! üìù\", \"done\": True}}\n                )\n\n            # limpeza com tratamento de erro\n            try:\n                if os.path.exists(doc_path):\n                    os.remove(doc_path)\n            except OSError as e:\n                logging.warning(f\"N√£o foi poss√≠vel remover arquivo tempor√°rio {doc_path}: {e}\")\n\n            return {\"message\": \"Download event triggered\"}\n\n        except HTTPException as e:\n            if __event_emitter__ and user_valves.show_status:\n                await __event_emitter__(\n                    {\"type\": \"status\", \"data\": {\"description\": f\"Erro ao salvar: {e.detail}\", \"done\": True}}\n                )\n            raise e\n        except Exception as e:\n            logging.error(f\"Erro inesperado na fun√ß√£o salvar para Word: {str(e)}\", exc_info=True)\n            if __event_emitter__ and user_valves.show_status:\n                await __event_emitter__(\n                    {\"type\": \"status\", \"data\": {\"description\": f\"Erro ao salvar: {str(e)}\", \"done\": True}}\n                )\n            raise HTTPException(status_code=500, detail=str(e))\n\n    # ===================== Convers√£o Markdown -> DOCX =====================\n\n    def _markdown_to_docx(\n        self,\n        doc,\n        md_text: str,\n        Inches,\n        Pt,\n        WD_TABLE_ALIGNMENT,\n        WD_ALIGN_PARAGRAPH,\n        OxmlElement,\n        qn,\n        RT,\n    ):\n        lines = md_text.splitlines()\n        i = 0\n        in_code = False\n        code_buffer: List[str] = []\n\n        while i < len(lines):\n            line = lines[i]\n\n            # --- bloco de c√≥digo ```\n            fence = self._match_code_fence(line)\n            if fence is not None:\n                if not in_code:\n                    in_code = True\n                    code_buffer = []\n                else:\n                    # fecha bloco\n                    self._add_code_block(doc, \"\\n\".join(code_buffer), Pt)\n                    in_code = False\n                    code_buffer = []\n                i += 1\n                continue\n            if in_code:\n                code_buffer.append(line)\n                i += 1\n                continue\n\n            # --- tabela Markdown\n            if self._looks_like_table_start(lines, i):\n                i = self._consume_table(doc, lines, i, WD_TABLE_ALIGNMENT)\n                continue\n\n            # --- headings\n            m_h = re.match(r\"^(#{1,6})\\s+(.*)$\", line.strip())\n            if m_h:\n                level = min(len(m_h.group(1)), 6)\n                text = m_h.group(2).strip()\n                doc.add_heading(text, level=level)\n                i += 1\n                continue\n\n            # --- horizontal rule\n            if re.match(r\"^\\s*([-_*])\\s*\\1\\s*\\1\\s*$\", line):\n                p = doc.add_paragraph(\"---\")\n                p.alignment = WD_ALIGN_PARAGRAPH.LEFT\n                i += 1\n                continue\n\n            # --- blockquote\n            m_bq = re.match(r\"^\\s*>\\s?(.*)$\", line)\n            if m_bq:\n                text = m_bq.group(1)\n                p = doc.add_paragraph(style=\"Quote\")\n                self._add_inline_markdown(doc, p, text, OxmlElement, qn, RT, Pt, Inches)\n                i += 1\n                continue\n\n            # --- listas\n            if self._is_list_item(line):\n                i = self._consume_list_block(doc, lines, i, OxmlElement, qn, RT, Inches, Pt)\n                continue\n\n            # --- par√°grafos\n            if line.strip() == \"\":\n                doc.add_paragraph(\"\")\n            else:\n                p = doc.add_paragraph()\n                self._add_inline_markdown(doc, p, line, OxmlElement, qn, RT, Pt, Inches)\n            i += 1\n\n        if in_code and code_buffer:\n            self._add_code_block(doc, \"\\n\".join(code_buffer), Pt)\n\n    # -------------------- Tabelas --------------------\n\n    def _looks_like_table_start(self, lines: List[str], idx: int) -> bool:\n        if idx >= len(lines):\n            return False\n        row_pat = r\"^\\s*\\|.*\\|.*\\s*$\"\n        if not re.search(row_pat, lines[idx]):\n            return False\n        # aceita com ou sem linha separadora\n        return True\n\n    def _consume_table(self, doc, lines: List[str], idx: int, WD_TABLE_ALIGNMENT):\n        row_pat = r\"^\\s*\\|.*\\|.*\\s*$\"\n        data: List[List[str]] = []\n        while idx < len(lines) and re.search(row_pat, lines[idx]):\n            cells = [c.strip() for c in lines[idx].strip().strip(\"|\").split(\"|\")]\n            # ignora separador\n            if not all(re.fullmatch(r\"[:\\-]+\", c) for c in cells):\n                data.append(cells)\n            idx += 1\n\n        if data:\n            headers = [str(h) for h in data[0]]\n            rows = data[1:] if len(data) > 1 else []\n            tbl = doc.add_table(rows=1, cols=len(headers))\n            tbl.style = \"Table Grid\"\n            tbl.alignment = WD_TABLE_ALIGNMENT.LEFT\n\n            hdr_cells = tbl.rows[0].cells\n            for j, h in enumerate(headers):\n                hdr_cells[j].text = h\n\n            for r in rows:\n                cells = tbl.add_row().cells\n                for j in range(len(headers)):\n                    cells[j].text = str(r[j]) if j < len(r) else \"\"\n            doc.add_paragraph(\"\")  # espa√ßo ap√≥s tabela\n\n        return idx\n\n    # -------------------- Listas --------------------\n\n    def _is_list_item(self, line: str) -> bool:\n        return bool(\n            re.match(r\"^\\s*([-+*])\\s+.+$\", line) or\n            re.match(r\"^\\s*\\d+[.)]\\s+.+$\", line)\n        )\n\n    def _consume_list_block(self, doc, lines: List[str], idx: int, OxmlElement, qn, RT, Inches, Pt):\n        while idx < len(lines) and self._is_list_item(lines[idx]):\n            line = lines[idx]\n            indent_spaces = len(line) - len(line.lstrip(\" \"))\n            level = min(indent_spaces // 2, 5)\n            text = line.strip()\n\n            m_num = re.match(r\"^(\\d+)[.)]\\s+(.+)$\", text)\n            m_bul = re.match(r\"^([-+*])\\s+(.+)$\", text)\n\n            if m_num:\n                item_text = m_num.group(2)\n                p = doc.add_paragraph(style=\"List Number\")\n            else:\n                item_text = m_bul.group(2) if m_bul else text\n                p = doc.add_paragraph(style=\"List Bullet\")\n\n            if level > 0:\n                p.paragraph_format.left_indent = Inches(0.25 * level)\n\n            self._add_inline_markdown(doc, p, item_text, OxmlElement, qn, RT, Pt, Inches)\n            idx += 1\n        return idx\n\n    # -------------------- Inline Markdown --------------------\n\n    def _add_inline_markdown(self, doc, paragraph, text: str, OxmlElement, qn, RT, Pt, Inches):\n        \"\"\"\n        Converte imagens, links, `code`, **bold**, *italic*, ~~strike~~.\n        Imagem:\n          - data URI: insere imagem (como par√°grafo separado no final do documento)\n          - http(s): cria hyperlink\n        \"\"\"\n        # Regex otimizado para prevenir ReDoS - usando possessive quantifiers quando poss√≠vel\n        token = re.compile(\n            r\"(!\\[(?P<i_alt>[^\\]]*)\\]\\((?P<i_url>[^)]+)\\))|\"           # imagem\n            r\"(\\[(?P<a_text>[^\\]]+)\\]\\((?P<a_url>[^)]+)\\))|\"           # link\n            r\"(`(?P<code>[^`]+)`)|\"                                    # code inline\n            r\"(\\*\\*\\*(?P<bii>[^*]+(?:\\*(?!\\*\\*)[^*]*)*)\\*\\*\\*)|\"        # bold+italic (otimizado)\n            r\"(\\*\\*(?P<bb>[^*]+(?:\\*(?!\\*)[^*]*)*)\\*\\*)|\"              # bold (otimizado)\n            r\"(__(?P<bb2>[^_]+(?:_(?!_)[^_]*)*)__)|\"                   # bold (_) (otimizado)\n            r\"(\\*(?P<ii>[^*]+)\\*)|\"                                    # italic\n            r\"(_(?P<ii2>[^_]+)_)|\"                                     # italic (_)\n            r\"(~~(?P<strike>[^~]+(?:~(?!~)[^~]*)*)~~)\"                 # strike (otimizado)\n        )\n\n        pos = 0\n        for m in token.finditer(text):\n            if m.start() > pos:\n                paragraph.add_run(text[pos:m.start()])\n\n            if m.group(\"i_url\") is not None:\n                alt = m.group(\"i_alt\") or \"imagem\"\n                url = m.group(\"i_url\")\n                self._handle_image_inline(doc, paragraph, alt, url, Inches, OxmlElement, qn, RT)\n            elif m.group(\"a_url\") is not None:\n                self._add_hyperlink(paragraph, m.group(\"a_text\"), m.group(\"a_url\"), OxmlElement, qn, RT)\n            elif m.group(\"code\") is not None:\n                r = paragraph.add_run(m.group(\"code\"))\n                r.font.name = \"Consolas\"\n                r.font.size = Pt(10)\n            elif m.group(\"bii\") is not None:\n                r = paragraph.add_run(m.group(\"bii\"))\n                r.bold = True; r.italic = True\n            elif m.group(\"bb\") is not None or m.group(\"bb2\") is not None:\n                r = paragraph.add_run(m.group(\"bb\") or m.group(\"bb2\"))\n                r.bold = True\n            elif m.group(\"ii\") is not None or m.group(\"ii2\") is not None:\n                r = paragraph.add_run(m.group(\"ii\") or m.group(\"ii2\"))\n                r.italic = True\n            elif m.group(\"strike\") is not None:\n                r = paragraph.add_run(m.group(\"strike\"))\n                r.font.strike = True\n\n            pos = m.end()\n\n        if pos < len(text):\n            paragraph.add_run(text[pos:])\n\n    def _handle_image_inline(self, doc, paragraph, alt: str, url: str, Inches, OxmlElement, qn, RT):\n        \"\"\"\n        data:image/... -> incorpora no documento (adicionado ao final).\n        http(s) -> hyperlink com texto alt.\n        \"\"\"\n        try:\n            if url.startswith(\"data:image/\"):\n                # Validar formato e tamanho da imagem\n                if \",\" not in url:\n                    paragraph.add_run(f\"[imagem inv√°lida: {alt}]\")\n                    return\n                    \n                header, b64data = url.split(\",\", 1)\n                \n                # Verificar tipo MIME permitido\n                allowed_types = [\"image/jpeg\", \"image/jpg\", \"image/png\", \"image/gif\", \"image/bmp\", \"image/webp\"]\n                mime_type = header.split(\":\")[1].split(\";\")[0] if \":\" in header else \"\"\n                if mime_type not in allowed_types:\n                    paragraph.add_run(f\"[tipo de imagem n√£o suportado: {alt}]\")\n                    return\n                \n                # Verificar tamanho da imagem (limite 10MB)\n                if len(b64data) > 10 * 1024 * 1024 * 4/3:  # base64 √© ~33% maior\n                    paragraph.add_run(f\"[imagem muito grande: {alt}]\")\n                    return\n                \n                try:\n                    data = base64.b64decode(b64data)\n                    stream = io.BytesIO(data)\n                    # Anexa ao documento (Word cria par√°grafo pr√≥prio)\n                    doc.add_picture(stream, width=Inches(4))\n                    # legenda simples opcional:\n                    doc.add_paragraph(alt)\n                except Exception as e:\n                    logging.warning(f\"Erro ao processar imagem base64: {e}\")\n                    paragraph.add_run(f\"[erro ao processar imagem: {alt}]\")\n                    \n            elif url.startswith(\"http://\") or url.startswith(\"https://\"):\n                self._add_hyperlink(paragraph, alt, url, OxmlElement, qn, RT)\n            else:\n                paragraph.add_run(f\"[imagem: {alt}]\")\n        except Exception as e:\n            logging.warning(f\"Erro ao processar imagem: {e}\")\n            paragraph.add_run(f\"[imagem: {alt}]\")\n\n    def _add_hyperlink(self, paragraph, text, url, OxmlElement, qn, RT):\n        \"\"\"\n        Cria hyperlink clic√°vel via API de baixo n√≠vel.\n        \"\"\"\n        part = paragraph.part\n        r_id = part.relate_to(url, RT.HYPERLINK, is_external=True)\n\n        hyperlink = OxmlElement(\"w:hyperlink\")\n        hyperlink.set(qn(\"r:id\"), r_id)\n\n        new_run = OxmlElement(\"w:r\")\n        rPr = OxmlElement(\"w:rPr\")\n        color = OxmlElement(\"w:color\"); color.set(qn(\"w:val\"), \"0000FF\")\n        u = OxmlElement(\"w:u\"); u.set(qn(\"w:val\"), \"single\")\n        rPr.append(color); rPr.append(u)\n        new_run.append(rPr)\n\n        t = OxmlElement(\"w:t\"); t.text = text\n        new_run.append(t)\n        hyperlink.append(new_run)\n        paragraph._p.append(hyperlink)\n\n    # -------------------- Blocos auxiliares --------------------\n\n    def _add_code_block(self, doc, code_text: str, Pt):\n        p = doc.add_paragraph()\n        for line in code_text.split(\"\\n\"):\n            r = p.add_run(line + \"\\n\")\n            r.font.name = \"Consolas\"\n            r.font.size = Pt(10)\n\n    def _match_code_fence(self, line: str):\n        m = re.match(r\"^\\s*```(\\w+)?\\s*$\", line)\n        return (m.group(1) or \"\").strip() if m else None\n\n    def _extract_main_title(self, content: str) -> str:\n        for line in content.splitlines():\n            m = re.match(r\"^#\\s+(.*)$\", line.strip())\n            if m:\n                return m.group(1).strip()\n        return \"\"\n\n    def _clean_filename(self, name: str) -> str:\n        # Remove caracteres inv√°lidos e limita tamanho\n        cleaned = re.sub(r'[\\\\/*?:\"<>|]', \"\", name).strip()\n        # Limitar tamanho do nome do arquivo (m√°ximo 100 caracteres)\n        if len(cleaned) > 100:\n            cleaned = cleaned[:97] + \"...\"\n        # Garantir que n√£o seja vazio\n        return cleaned if cleaned else \"documento\"\n"}]